# 2019.11.02 Toby



> DI와 추상화, 기능을 구현하는 코드의 아키텍처의 퀄리티를 높이는 기술



- **토비의 스프링**
  - 6장 마무리
  - 7장 시작



##  **각 장의 정리 다시보기**

### **2장 테스트** 

1. 테스트는 자동화되어야 한다. 빠르게 실행할 수 있어야 한다.
2. main() 테스트 대신 **JUnit 프레임워크를 이용한 테스트 작성이 편리**하다.
3. **테스트 결과는 일관성**이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
4. 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
5. 코드 작성과 테스트 수행의 간격이 짧을 수록 효과적이다.
6. 테스트하기 쉬운 코드가 좋은 코드이다.
7. 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발방법도 유용하다.
8. 테스트 코드도 어플리케이션 코드와 마찬가지로 적절한 리펙토링이 필요하다.
9. **@Before, @After**를 사용해서 테스트 메서드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
10. 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
11. 동일한 설정파일을 사용하는 테스트는 하나의 어플리케이션 컨텍스트를 공유한다.
12. **@Autowired**를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
13. 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성
14. 오류가 발견될 경우 그게 대한 버그 테스트를 만들어두면 편하다.



### **3장 템플릿**

1. JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리
2. 일정한 작업 흐름이 반복되면서 그 중 일부 기능만 바뀌는 코드가 존재한다면 **전략 패턴**을 적용, **바뀌지 않는 부분은 컨텍스트**로, **바뀌는 부분은 전략**으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성
3. 같은 어플리케이션 안에서 여러 가지 종류의 전략을 다이나믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메서드에서 직접 전략을 정의하고 제공하게 만든다.
4. 클라이언트 메서드 안에 **익명 내부 클래스를 사용하여 전략 오브젝트를 구현**하면 코드도 간결해지고 메서드의 정보를 직접 사용할 수 있어서 편리
5. 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리하여 공유
6. 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 때 커텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI 해줄 수 있다.
7. 단일 전략 메서드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용하여 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 **템플릿/콜백 패턴**이라고 한다.
8. 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리
9. 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용
10. 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과  콜백을 제공
11. 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다.
12. 템플릿/콜백 설계할 때는 템플릿과 콜백 사이에 주고 받는 정보에 관심을 두어야 한다.



### **4장 예외**

1. 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험
2. 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
3. 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
4. 복구할 수 없는 예외는 가능한 빨리 런타임 예외로 전환하는 것이 바람직하다.
5. 어플리케이션 로직을 담기 위한 예외는 체크 예외로 만든다.
6. JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
7. SQLException의 에러 코드는 DB에 종속되기 때문에 **DB에 독립적인 예외로 전환**될 필요가 있다.
8. 스프링은 **DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층**을 제공
9. DAO를 데이터 액세스 기술에서 독립시키려면 **인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요**하다.



### **5장 서비스 추상화**

1. 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다.
   - 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메서드로 정리되어야 한다.
2. 이를 위해서 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용하여 결합도를 낮춰야 한다.
3. DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.
4. 트랜잭션의 시작과 종료를 지정하는 일을 **트랜잭션 경계설정**이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
5. 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 **트랜잭션 동기화 기법**을 활용하는 것이 편리
   - 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경되어야 한다.
   - 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
6. 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 **트랜잭션 서비스 추상화**를 이용하면 된다.
   - 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
   - 서비스 추상화는 테스트하기 어려운 JavaMail 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
7. 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 **테스트 대역**이라 한다.
   - 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
   - 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 **목 오브젝트**라 한다.



### **6장 AOP**

1. 트랜잭션 경계 설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다.
2. 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.
3. 목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수 있다.
4. DI를 이용한 트랜잭션의 분리는 **데코레이터 패턴**과 **프록시 패턴**으로 이해될 수 있다.
5. 번거로운 프록시 클래스 작성은 JDK의 다이나믹 프록시를 사용하면 간단하게 만들 수 있다.
6. 다이나믹 프록시는 스태틱 팩토리 메서드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
7. 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기의 포인트컷을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
8. 포인트컷은 **AspectJ 포인트컷 표현식**을 사용해서 작성하면 편리하다.
9. AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
10. 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있는 전용 태그를 제공한다.
11. AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메서드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 **@Transactional 어노테이션**을 사용하는 방법이 있다.
    - @Transactional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.